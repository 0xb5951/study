ツリー構造について
リスト構造のノードにおいて、次のノードを複数持てるようにしたもの。

ワード
１つ前のノード     親ノード
次のノード     　　子ノード
同じ親を持つノード　兄弟ノード
子を持たないノード　葉（leaf）
ツリー全体の根本　　根(root)

基本的な動作
1.あるノードに新しい子ノードを追加する
2.あるノードと子/親ノードの間にノードを追加する
3.葉を切り取る
4.途中のノードを切るとる
5.部分的なツリー構造を丸ごと追加したり削除したりする

2分木(binary tree)
あるノードが最大2個しか子ノードを持たない木構造。
２分木では構造体を使う。
最初に1つ用意してツリーの根にする。
その根に対して、根にデータをどんどん追加したり、
必要に応じて検索したりデータを削除する。

typedef struct _tag_tree_node {
  //このノードが保持する値
  int value;
  struct _tag_tree_node *left;
  struct _tag_tree_node *right;
} tree_node;


複数の子ノードを持つツリー（多分木）
2分木を拡張して、1つのノードがたくさんの子ノードをもつようにしたもの。
このようなツリーがディレクトリやファイル構造など様々な場面に応用可能
この場合、子ノードのポインタをポインタ配列にして、for文やwhile文などで子ノードに対する処理を行う。

平衡木
ツリー構造において最も理想的な構造は「ツリーが左右にバランスが取れた形で枝分かれが豊富」という状態。
逆に最も最悪な状態は「全てのノードが分岐なくつながり、リストと同じ状況になる」という状態。
2分木の検索効率を上げるにはツリーができるだけ横方向につながり、高さを低く抑えることが重要。
そこでツリーの形を理想状態に保つために考え出されたのが、平衡木という概念。
これはルートからどの葉までたどっても同じ数のノードを経由するような木。
これには探索などの処理の際、処理時間の平均を短縮することができるというメリットがある。
ツリーが平衡木を保つにはノードが追加/削除されるたびに各ノードの位置を適切に修正/配置し、
高さをそろえ、バランスをとることが重要となる。

AVL木
平衡木の一種。
Adel'son-VelskiiとLandisによって開発された平衡木で次のようね条件で定義される。
「どのノードをとっても、そのノードにぶら下がっている左右の子孫高さの差が1以内」
つまり、ツリーの高さが全ての葉において高さが1以内ということ。
ツリーを常にAVL木の状態に保っておくには、「回転」という作業が必要になる。
回転はツリー構造をノード追加点の肩を引き上げる作業。追加したノードが一番上に行く。
論理：ALV木の平衡点にノードを追加したらAVL木ではなくなる。これを整えるために、
　　　追加したノードをツリー構造ごと引き上げて、バランスをとる。

B木
B木は市販のデータベースエンジンのほとんどで使われている非常に実用的なデータ構造。
データがランダムな順番で追加されても常にO(logN)の速度で応答することができる。
B木では１つのノードが複数個のデータを保持する。データを保持しているノードを「ページ」、
1つのノードが保持するデータの数を「ページサイズ」と呼ぶ。
