大量のデータを扱う方法は配列だけではない。ここでは「リスト」を説明する。

まず配列のデメリットをプログラムと共に示す。

ex.いくつ入力されるかわからないデータ
//ユーザが入力した数値の合計値を算出するプログラム
#include <stdio.h>
#include <stdlib.h>

#define NMAX 100

int main(void){
  int buf, sum, count, n;
  int array{NMAX};

  count = 0;
  do {
    printf("整数を入力してください(0を入力すると終了):");
    scanf("%d", &buf);
    if(buf){
      array[count] = buf;
      count++;
    }
  }while(buf != 0);

  /*合計値を算出*/
  printf("--入力された値は以下の数です--\n");
  for(sum = n = 0; n < count; n++) {
    printf("%d \t", array[n]);
    sum += array[n];
  }
  printf("\n---\n以上の数の合計値は%dです。\n", sum);

  return EXIT_SUCCESS;
}

ここで問題となるのは確保する配列のデータをいくらにするか、ということ。
上の場合、データが10個以上入力されるとプログラムがクラッシュしてしまう。
これを防ぐために1000個や一万個のデータ領域を確保したとしても、入力が
数個しかない場合、無駄に大きな領域を確保したことになってしまう。
解決法として先に入力予定のデータを確保しておくといった手法や
配列があふれそうになったときに配列を拡張するという方法
が考えられるが得策ではない。

入力されるデータがいくつあるかわからない場合どうするか。
ここで登場するのが「リスト」。
リストはデータが追加されるたびにメモリを確保し、既存のリストの末尾に追加することで
動的に大量のデータを扱うことが可能となる。
以下にリストの特徴を示す。

1．ポインタを使って前後の位置関係を把握する
リストの各要素はそれぞれのメモリ内でバラバラに格納されている。
これに順番付けを行うために各ノードがそれぞれの前後のノードの位置をポインタを
使って把握している。末尾のノードには次のノードがないので、「NULL」を入れておく。

2.ノードの追加/削除が簡単
配列はまとまった連続の領域を確保しているのでデータの移動が難しい。
しかしリストはノードの前後関係のみを把握しておけばいいので、
ばらばらの位置にデータを確保しておける。
なので、要素を追加、削除したい場合はノードのポインタの参照関係を
変更するだけでいいのでかなり簡単。

しかし、単純な性能でいえば配列の方が上。
理由はメモリの開放と確保。メモリを確保する関数は意外に処理コストが高い。
これらの関数を頻繁に呼び出すと、スピード面で劣化してしまう。
配列は必要なデータを一括で確保するので、メモリ確保にさほど時間がかからない。
リストはノードごとにメモリを確保しなければならないのでかなり遅い。

リストと配列の違い
リストは配列のように"[]"を使ってデータを扱うことができない．先頭から順にたどっていくか
末尾から前にたどっていくしかない．つまりリストはデータに対して飛び飛びにアクセスしたい
場合には向いていない．ただ頻繁にデータの削除/挿入を行う場合には優れている．
