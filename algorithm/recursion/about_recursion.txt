再帰呼び出しについての説明
再帰呼び出しとはある関数の中で同名の関数が何度も呼び出されること。

これを使うと多様性に富んだ処理の繰り返しを行うことができる。
ただfor文やwhile文みたいにはっきりと構造を得ることが難しいためちょっと難易度高め。

仕組み
ここではある文字列の中に１がどれだけ含まれているかを判断するプログラムを例に考える。

for文の例
for文では各桁を一つ一つ調べて見つかった１の合計を返す。
桁を入れ替えるために値を10で割っていく。

int num_of_one(int value){
  int ret;
  for(ret = 0; value > 0; value /= 10) {
    if(vaule % 10 == 1){
      ret++;
    }
  }
  return ret;
}

再帰を使った場合
1.0を与えた場合
　valueが0になるのでプログラム終了

2.1桁の数字を与えた場合
　value%10 == 1　で判断する。あまりが1だとtrue。
　これを再帰させる。valueは10で割ってある。
　ｃ言語は割り算の小数点以下は切り捨てなのでこの後は0が入る。

3.２桁の数を与えた場合。
value%10 == 1　で判断する。あまりが1だとtrue。
なので同じ処理を用いて再帰処理を行うことができる。
なので最終的な戻り値は
 10の位のret 1 + １の位のret 0　となる。

int num_of_one(unsigned long value) {
  int ret;
  /*valueが0桁（もうこれ以上解析する桁がない）*/
  if(ret == 0){
    return 0;
  }
  if(value % 10 == 1){
    ret = 1;
  } else {
    ret = 0;
  }

  /*10で割って桁を一つずらし、再びnum_of_one()を調べる*/
  return ret + num_of_one(value % 10);
}

/*簡易版*/
int num_of_one(unsigned long value){
  if(value == 0){
    return 0;
  }
  return (((value % 10) == 1) ? 1: 0) + num_of_one(value/10);
}

再帰は入れ子状態が何重にもなる処理に対して有効。
またツリー構造やgraphなど一般に再帰的なデータと呼ばれるものに対して処理を行うときに
特に威力を発揮する。
たとえばディレクトリを用いた階層的なファイル構造を扱う際には非常に便利で
ディレクトリ単位での操作をサポートするプログラムは再帰を使用すると吉。

しかし、再帰を使うには注意が必要。
最も典型的なものはプログラムが永久に停止しなくなるといったもの。
以下の例を例を見てみましょう。

1.無限に再帰呼び出しが続くケース
int foo(int n){
  n /= 2;
  return n + foo(n);
}

これは再帰の終了条件を書いていないため無限にループが発生する。
次は終了条件を書き足してみよう。

2.再帰呼び出しに終了条件を設けてみた
int foo(int n){
  if(n == 0) {
    return 0;
  } else {
    return n + foo(n);
  }
}

終了条件を設けてみた。けどこれでも無限ループしてしまう。
これは終了条件がいつまでたっても満たされないことに起因する。
終了条件はちゃんと達成できるようなものを設定することが大切。

3.再帰呼び出しに有効な終了条件を設けたケース
int foo(int n){
  if(n == 0){ //終了条件
    return 0;
  } else {
    n /= 2; //これを繰り返せば、いずれnが0になる
    return n + foo(n);
  }
}

これで終了条件ができました。


ただむやみに再帰を使うのは危険だと指摘する人もいる。
再帰はその性質上「終了条件に達するまで自分自身を呼び出し続ける」
動作を行います。なのでそのたびにコンピュータのメモリリソースを消費し、
与えたデータのサイズによってはメモリ不足のために不正終了する場合もある。
また関数呼び出しのオーバーヘッド問題のため、一般に再帰呼び出しを
利用したプログラムは動作速度が遅くなる傾向にある。
