マップについての説明。
大量のデータから特定の値を探したいとき、どのような構造だと効率がいいのか。

従来の方法では、構造体やリストを作っておいて、それにたいしてリニアサーチやバイナリサーチを行う方法が
考えられる。これでも確かに検索はできるが、データの追加や削除、検索の効率が悪い。

そこで、以下のような条件を満たすデータ構造が必要になる。
・ある検索キーを元に、対応する値を取得できる
・データの追加と削除が高速
・検索も高速

この条件を満たすデータ構造に「マップ」がある。これに格納する検索キーや値は文字でも数値でも問題なし。
一般的にマップと呼ばれるものには2種類ある。
1.バイナリツリーを使った「ツリーマップ」     比較的簡単に実装可能
2.ハッシュ表を使った「ハッシュマップ」　　　　高速処理が可能

ツリーマップ
バイナリツリーを使って、以下のようなルールでマップを作る。
・「キー+値」の構造体を保持するバイナリツリーを作る
・各ノードはキーの大小関係に基づいて整理する。
ツリーマップのデータ追加/削除、検索にかかる計算量オーダは最も速い場合でO(logN)、
最も重い場合でO(N)になる。データの分布や追加順番によって処理速度が大きく変わってしまい、
パフォーマンス的には安定しない。

ハッシュマップ
入力される文字列（キー）を一定限度のランダムな値に変換し、それと格納する配列やリストの番号と
結びつける。通常、配列の添え字には非負整数しか使えない。
キーを要約する値であるハッシュ値を管理番号として用いることで処理によらず、定数時間O(1)で
の動作を実現する。ハッシュはあるデータを一方向にしか演算できず、ハッシュ化された値から元の値を
計算することはほぼ不可能。
ハッシュマップはその特性上、格納先の容量を多めに用意しておく必要があるため、メモリ使用量は
多くなるが、非常に優れた方法。
ハッシュテーブルはエントリの数が配列のサイズに近づくほど衝突の確率が高くなり、性能が悪化してしまう。
この比率をload factor(座席利用率)と呼び、n/Nの形で表す。nはエントリの数、Nは配列のサイズを指す。
複数の異なるキーが同じハッシュ値になることを衝突 (collision) と呼ぶ。
衝突が発生したときの対処の方法は、開番地法と連鎖法に大別される。
開番地法
衝突が発生した際、テーブル中の空いている別の番地を探す方式を開番地法と呼ぶ。
その方法としてハッシュ関数とは別の関数を用いて次の候補となる番地を求める。
別の番地を探す関数は繰り返し適用することによってテーブル内の全ての番地を走査できるように選ぶ。
連鎖法
衝突を起こしたキー同士をポインタでつなぐ方式を連鎖法と呼ぶ。
テーブルの各番地にはキーそのものではなく、同族キーを保持するリンクリストを格納する。
ここで重要になるのは、ハッシュ値の決め方。
比較的単純なものは与えられた文字列のASCIIコードに直し、各文字に16のべき乗の重率をかけてから
足し合わせる方法。もっと本格的にするにはCRC16/CRC32を使うといい。
またハッシュテーブルの容量を素数にすると性能が向上する。これは誕生日のパラドックスと同じ計算。
つまりよりランダムな値が生成できるということ。
